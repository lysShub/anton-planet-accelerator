
// todo: only work on udp
func New(listenUdpPort uint16) (*forward, error) {
	var f = &forward{}

	ifi, err := net.InterfaceByName("eth0") // todo: fix
	if err != nil {
		return nil, err
	}
	var to net.HardwareAddr
	if c, err := arp.Dial(ifi); err != nil {
		return nil, errors.WithStack(err)
	} else {
		var gateway netip.Addr
		if rows, err := route.GetTable(); err != nil {
			return nil, err
		} else {
			for _, e := range rows {
				if e.Interface == uint32(ifi.Index) {
					gateway = e.Next
					break
				}
			}
		}
		if !gateway.IsValid() {
			return nil, errors.Errorf("interface %s not network connect", ifi.Name)
		}
		if to, err = c.Resolve(gateway); err != nil {
			return nil, errors.WithStack(err)
		}
	}

	f.conn, err = eth.Listen("eth:ip4", ifi)
	if err != nil {
		return nil, err
	}
	f.to = to

	var prog *unix.SockFprog
	if ins, err := bpf.Assemble(bpfFilterUdpPort(listenUdpPort)); err != nil {
		return nil, f.close(err)
	} else {
		prog = &unix.SockFprog{
			Len:    uint16(len(ins)),
			Filter: (*unix.SockFilter)(unsafe.Pointer(&ins[0])),
		}
	}
	var e error
	if err := f.conn.SyscallConn().Control(func(fd uintptr) {
		e = unix.SetsockoptSockFprog(int(fd), unix.SOL_SOCKET, unix.SO_ATTACH_FILTER, prog)
	}); err != nil {
		return nil, f.close(err)
	} else if e != nil {
		return nil, f.close(e)
	}

	return f, nil
}

func (f *forward) close(cause error) error {
	panic("")
}

func (f *forward) Run() {

}

func (f *forward) UpdateNexts(rss net.Conn) {
}

func (f *forward) AddNext(next netip.Addr) {

}
func (f *forward) DelNext(net netip.Addr) {

}

func bpfFilterUdpPort(udpPort uint16) []bpf.Instruction {
	const IPv4ProtocolOffset = 9
	const UDPDstPortOffset = header.TCPDstPortOffset
	var ins = []bpf.Instruction{
		// filter udp
		bpf.LoadAbsolute{Off: IPv4ProtocolOffset, Size: 1},
		bpf.JumpIf{Cond: bpf.JumpEqual, Val: unix.IPPROTO_UDP, SkipTrue: 1},
		bpf.RetConstant{Val: 0},

		// store IPv4HdrLen regX
		bpf.LoadMemShift{Off: 0},

		// skip udp dst port
		bpf.LoadIndirect{Off: UDPDstPortOffset, Size: 2}, //
		bpf.JumpIf{Cond: bpf.JumpEqual, Val: uint32(udpPort), SkipTrue: 1},
		bpf.RetConstant{Val: 0},

		bpf.RetConstant{Val: 0xffff},
	}
	return ins
}
